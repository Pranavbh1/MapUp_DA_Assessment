{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ea868f08-5e48-4200-92ff-b9ed5bba6a64",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "#Question 1: Car Matrix Generation\n",
    "def generate_car_matrix(dataset):\n",
    "    car = df1.pivot(index='id_1', columns='id_2', values='car').fillna(0)            #pivot table\n",
    "    return car\n",
    "\n",
    "dataset = 'dataset-1.csv'\n",
    "result_matrix = generate_car_matrix(dataset)\n",
    "print(result_matrix)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Question 2: Car Type Count Calculation\n",
    "def get_type_count(dataset):     \n",
    "    conditions = [(df1.car <= 15),(df1.car > 15) & (df1.car <= 25),(df1.car > 25)]     #Multiple conditions\n",
    "    car_types = ['low', 'medium', 'high']                                              #Defining car types for consitions \n",
    "    df1.car_type = np.select(conditions, car_types)                                    #Creating new column\n",
    "    type_count = df1.car_type.value_counts().to_dict()                                 #Creating Dictionary\n",
    "    type_count = {i: type_count[i] for i in sorted(type_count)}\n",
    "\n",
    "    return type_count\n",
    "\n",
    "dataset = 'dataset-1.csv'\n",
    "result_type_count = get_type_count(dataset)\n",
    "print(result_type_count)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Question 3: Bus Count Index Retrieval\n",
    "def get_bus_indexes(dataset):    \n",
    "    bus_idxs = df1[df1.bus > 2 * df1.bus.mean() ].index.tolist()            #Applying Condition + returning List\n",
    "    bus_idxs.sort()\n",
    "\n",
    "    return bus_idxs\n",
    "\n",
    "dataset = 'dataset-1.csv'\n",
    "result_bus_indexes = get_bus_indexes(dataset)\n",
    "print(result_bus_indexes)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Question 4: Route Filtering\n",
    "def filter_routes(dataset):\n",
    "    selected_routes = (df1.groupby('route')['truck'].mean()).index.tolist()   #Groupby + apply mean + combine\n",
    "    selected_routes.sort()\n",
    "\n",
    "    return selected_routes\n",
    "\n",
    "dataset = 'dataset-1.csv'\n",
    "result_routes = filter_routes(dataset)\n",
    "print(result_routes)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Question 5: Matrix Value Modification\n",
    "def multiply_matrix(input_matrix):   \n",
    "    matrix = input_matrix.copy()                          #Making a copy of parameter\n",
    "    matrix[matrix > 20] *= 0.75                           #Updating with Condition 1\n",
    "    matrix[matrix <= 20] *= 1.25                          #Updating with Condition 2\n",
    "    matrix = np.round(matrix , 1)                         #Rounding off\n",
    "\n",
    "    return matrix\n",
    "\n",
    "result_mtrx = generate_car_matrix('dataset-1.csv')\n",
    "final_result = multiply_matrix(result_mtrx)\n",
    "print(final_result)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Question 6: Time Check\n",
    "def time_check(dataset):\n",
    "    #Creating new column by typecasting and concatenating with given format\n",
    "    df2.start_datetime = pd.to_datetime(df2.startDay + ' ' + df2.startTime, errors='coerce' , format='%H:%M:%S')\n",
    "    #Creating new column by typecasting and concatenating with given format\n",
    "    df2.end_datetime = pd.to_datetime(df2.endDay + ' ' + df2.endTime, errors='coerce', format='%H:%M:%S')\n",
    "    #Grouping by and applying anonymous function with resetting the indexes\n",
    "    time_completeness = df2.groupby(['id', 'id_2']).apply(lambda x: check_timestamps(x)).reset_index(drop=True)\n",
    "\n",
    "    return time_completeness\n",
    "\n",
    "def check_timestamps(group):\n",
    "    min_datetime = group.start_datetime.min()      #Finding the mininmum\n",
    "    max_datetime = group.end_datetime.max()        #Finding the maximum\n",
    "\n",
    "    if pd.notna(min_datetime) and pd.notna(max_datetime):                    #Detecting existing (non-missing) values and #Updating correct range\n",
    "        correct_range = (min_datetime.time() == pd.Timestamp('00:00:00').time()) and \\\n",
    "                        (max_datetime.time() == pd.Timestamp('23:59:59').time()) and \\\n",
    "                        (min_datetime.day_name() == 'Monday') and \\\n",
    "                        (max_datetime.day_name() == 'Sunday')\n",
    "    else:\n",
    "        correct_range = False\n",
    "\n",
    "    return not correct_range\n",
    "\n",
    "dataset = 'dataset-2.csv'\n",
    "result_completeness = time_check(dataset)\n",
    "print(result_completeness)\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
